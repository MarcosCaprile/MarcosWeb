<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Universe Simulator · Marcos Caprile-Santos</title>
  <meta name="description" content="Universe Simulator (Showcase) – interaktives 3D-Sonnensystem mit Zoom, Rotation, Speed und Follow-Body." />
  <link rel="canonical" href="https://marcos.caprile.net/projects/universe.html" />

  <link rel="icon" type="image/png" href="/favicon.png" />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Fraunces:wght@600&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

  <link rel="stylesheet" href="/styles.css?v=999" />

  <meta name="robots" content="index, follow" />
</head>

<body>
  <!-- Topbar (auf Projektseiten immer sichtbar) -->
  <nav class="topbar visible" id="topbar">
    <div class="wrap nav-inner">
      <a class="logo" href="/#hero" aria-label="Home">MCS</a>

      <button class="menu-btn" id="menuBtn" aria-label="Menü öffnen" aria-expanded="false">
        <span></span><span></span><span></span>
      </button>

      <div class="nav-links" id="navLinks">
        <a href="/#about">Über mich</a>
        <a href="/#cv">Lebenslauf</a>

        <!-- Projekte Dropdown (Desktop hover / Mobile tap) -->
        <div class="dropdown" id="projectsDropdown">
          <button class="dropbtn" type="button" aria-expanded="false">
            Projekte <span class="chev"></span>
          </button>
          <div class="dropmenu" role="menu" aria-label="Projekte">
            <a href="/projects/studyconnect.html">StudyConnect</a>
            <a href="/projects/newton.html">N.E.W.T.O.N.</a>
            <a href="/projects/thoughtra.html">Thoughtra</a>
            <a href="/projects/impostor-games.html">Impostor Games</a>
            <a href="/projects/securescreen.html">SecureScreen SDK</a>
            <div class="dropsep"></div>
            <a href="/projects/universe.html" aria-current="page">Universe Simulator</a>
          </div>
        </div>

        <a href="/#activities">Activities</a>
        <a href="/#qa">Fragebogen</a>
        <a href="/#social">Social</a>
        <a href="/#contact">Kontakt</a>

      </div>
    </div>
  </nav>

  <main class="wrap">
    <section class="card reveal">
      <h2>Universe Simulator</h2>
      <p class="muted">
        Showcase eines interaktiven 3D-Sonnensystems: Sterne, Orbits, Zeitlauf, Speed-Slider und “Follow-Body”.
        (Visual Simulator – keine Veröffentlichung der vollständigen Physik-Details.)
      </p>
    </section>

    <section class="card reveal">
      <div class="universe">
        <div class="universe-top">
          <div class="universe-title">
            <h3 class="mini" style="margin:0">Interactive 3D Showcase</h3>
            <div class="universe-time" id="timeLabel">t = 0.00 Jahre (0 Tage)</div>
          </div>

          <div class="universe-controls">
            <label class="u-field">
              <span>Tage / Schritt</span>
              <input id="speed" type="range" min="0.1" max="50" step="0.1" value="1.0" />
              <b id="speedVal">1.0</b>
            </label>

            <label class="u-field">
              <span>Follow</span>
              <select id="follow">
                <option value="none">Keiner</option>
                <option value="Merkur">Merkur</option>
                <option value="Venus">Venus</option>
                <option value="Erde">Erde</option>
                <option value="Mond">Mond</option>
                <option value="ISS">ISS</option>
                <option value="GPS-1">GPS-1</option>
                <option value="Starlink-1">Starlink-1</option>
                <option value="Mars">Mars</option>
                <option value="Jupiter">Jupiter</option>
                <option value="Saturn">Saturn</option>
                <option value="Uranus">Uranus</option>
                <option value="Neptun">Neptun</option>
              </select>
            </label>

            <button class="u-btn" id="resetView" type="button">Reset View</button>
          </div>
        </div>

        <!-- WICHTIG: bekommt über CSS eine echte Höhe -->
        <div class="universe-canvas" id="sceneWrap" aria-label="Universe Simulator Canvas"></div>

        <div class="universe-foot muted">
          <span>Drag = Rotate</span> · <span>Wheel = Zoom</span> · <span>Right click = Pan</span>
        </div>
      </div>
    </section>

    <section class="card reveal">
      <h3 class="mini">Was hier drin steckt</h3>
      <ul class="bullets">
        <li>3D-Sonnensystem + Sterne-Hintergrund</li>
        <li>Planetengrößen skaliert (komprimiert, damit alles sichtbar bleibt)</li>
        <li>Elliptische Orbits (dashed)</li>
        <li>Speed-Slider (Tage pro Schritt)</li>
        <li>Follow-Body (Kamera folgt sanft einem Objekt)</li>
      </ul>

      <p class="fine"><a href="/#projects">← zurück zur Startseite</a></p>
    </section>
  </main>

  <footer class="wrap footer">
    <p>© <span id="y"></span> Marcos Caprile-Santos</p>
    <p class="fine"><a href="/impressum.html">Impressum</a> · <a href="/datenschutz.html">Datenschutz</a></p>
  </footer>

  <!-- THREE.JS (CDN) -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

    // ===== Basics / UI =====
    document.documentElement.classList.add("js");
    const y = document.getElementById("y");
    if (y) y.textContent = new Date().getFullYear();

    const speed = document.getElementById("speed");
    const speedVal = document.getElementById("speedVal");
    const followSel = document.getElementById("follow");
    const timeLabel = document.getElementById("timeLabel");
    const resetBtn = document.getElementById("resetView");

    if (speed && speedVal) {
      speed.addEventListener("input", () => speedVal.textContent = Number(speed.value).toFixed(1));
    }

    // Mobile menu
    const menuBtn = document.getElementById("menuBtn");
    const navLinks = document.getElementById("navLinks");
    if (menuBtn && navLinks) {
      menuBtn.addEventListener("click", () => {
        const open = navLinks.classList.toggle("open");
        menuBtn.classList.toggle("open", open);
        menuBtn.setAttribute("aria-expanded", open ? "true" : "false");
      });
    }

    // Dropdown (mobile tap)
    const dd = document.getElementById("projectsDropdown");
    const ddBtn = dd ? dd.querySelector(".dropbtn") : null;
    if (dd && ddBtn) {
      ddBtn.addEventListener("click", (e) => {
        if (window.matchMedia("(max-width: 720px)").matches) {
          e.preventDefault();
          const open = dd.classList.toggle("open");
          ddBtn.setAttribute("aria-expanded", open ? "true" : "false");
        }
      });
    }

    // ===== Scene setup =====
    const wrap = document.getElementById("sceneWrap");
    if (!wrap) throw new Error("sceneWrap not found");

    const scene = new THREE.Scene();

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 1);
    renderer.outputColorSpace = THREE.SRGBColorSpace;

    // IMPORTANT: size after we know actual height
    const camera = new THREE.PerspectiveCamera(55, 1, 0.01, 2000);
    camera.position.set(0, 18, 52);

    wrap.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.minDistance = 6;
    controls.maxDistance = 260;

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.35));
    const sunLight = new THREE.PointLight(0xfff3c4, 2.1, 0, 1.3);
    sunLight.position.set(0, 0, 0);
    scene.add(sunLight);

    // ===== Stars background =====
    const starCount = 1200;
    const starGeo = new THREE.BufferGeometry();
    const starPos = new Float32Array(starCount * 3);
    for (let i = 0; i < starCount; i++) {
      const r = 90 + Math.random() * 70;
      const u = Math.random();
      const v = Math.random();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);
      starPos[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
      starPos[i * 3 + 1] = r * Math.cos(phi);
      starPos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
    }
    starGeo.setAttribute("position", new THREE.BufferAttribute(starPos, 3));
    const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.6, transparent: true, opacity: 0.55 });
    scene.add(new THREE.Points(starGeo, starMat));

    // ===== Helpers =====
    const AU_SCALE = 1.0;
    const DAY_IN_YEARS = 1 / 365.25;

    const sizeFromRadius = (rEarth = 6371, rKm = 6371, isSun = false) => {
      const rel = Math.max(rKm / rEarth, 0.00001);
      let s = 0.45 * Math.pow(rel, 0.3);
      if (isSun) s *= 1.6;
      return THREE.MathUtils.clamp(s, 0.18, 1.2);
    };

    const makeSphere = (color, radius) => {
      return new THREE.Mesh(
        new THREE.SphereGeometry(radius, 32, 22),
        new THREE.MeshStandardMaterial({ color, roughness: 0.7, metalness: 0.05 })
      );
    };

    const makeOrbit = (a, e, color) => {
      const pts = [];
      const seg = 420;
      for (let i = 0; i <= seg; i++) {
        const t = (i / seg) * Math.PI * 2;
        const x = (a * Math.cos(t) - a * e) * AU_SCALE;
        const z = (a * Math.sin(t) * Math.sqrt(1 - e * e)) * AU_SCALE;
        pts.push(new THREE.Vector3(x, 0, z));
      }
      const geo = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineDashedMaterial({ color, dashSize: 0.9, gapSize: 0.55, transparent: true, opacity: 0.35 });
      const line = new THREE.Line(geo, mat);
      line.computeLineDistances();
      return line;
    };

    const bodyDefs = [
      { name: "Sonne",   color: 0xffd24a, rKm: 695700, a: null, e: 0,    periodY: 0,    isSun: true },
      { name: "Merkur",  color: 0xa8a8a8, rKm: 2439.7, a: 0.387,  e: 0.2056, periodY: 0.241 },
      { name: "Venus",   color: 0xffa24a, rKm: 6051.8, a: 0.723,  e: 0.0068, periodY: 0.615 },
      { name: "Erde",    color: 0x3aa8ff, rKm: 6371.0, a: 1.000,  e: 0.0167, periodY: 1.000 },
      { name: "Mars",    color: 0xff3a2f, rKm: 3389.5, a: 1.524,  e: 0.0934, periodY: 1.881 },
      { name: "Jupiter", color: 0xd9a06a, rKm: 69911,  a: 5.203,  e: 0.0489, periodY: 11.86 },
      { name: "Saturn",  color: 0xd7b05a, rKm: 58232,  a: 9.537,  e: 0.0542, periodY: 29.46 },
      { name: "Uranus",  color: 0x6fe7ff, rKm: 25362,  a: 19.191, e: 0.0472, periodY: 84.01 },
      { name: "Neptun",  color: 0x7a4dff, rKm: 24622,  a: 30.07,  e: 0.0086, periodY: 164.8 },
    ];

    const bodies = new Map();

    for (const def of bodyDefs) {
      const radius = sizeFromRadius(6371, def.rKm, !!def.isSun);
      const mesh = makeSphere(def.color, radius);
      mesh.name = def.name;

      if (def.isSun) {
        mesh.material.emissive = new THREE.Color(0xffc85a);
        mesh.material.emissiveIntensity = 0.6;
      }

      scene.add(mesh);
      bodies.set(def.name, { def, mesh, theta: Math.random() * Math.PI * 2 });

      if (def.a) scene.add(makeOrbit(def.a, def.e, def.color));
    }

    // Moon + satellites
    const earth = bodies.get("Erde");
    const moonMesh = makeSphere(0xd0d0d0, 0.22); scene.add(moonMesh);
    const issMesh  = makeSphere(0xffffff, 0.12); scene.add(issMesh);
    const gpsMesh  = makeSphere(0x46ff6a, 0.11); scene.add(gpsMesh);
    const slMesh   = makeSphere(0x6fe7ff, 0.10); scene.add(slMesh);

    bodies.set("Mond",      { def: { name:"Mond" },      mesh: moonMesh, theta: 0 });
    bodies.set("ISS",       { def: { name:"ISS" },       mesh: issMesh,  theta: 0 });
    bodies.set("GPS-1",     { def: { name:"GPS-1" },     mesh: gpsMesh,  theta: 1.1 });
    bodies.set("Starlink-1",{ def: { name:"Starlink-1" },mesh: slMesh,   theta: 2.2 });

    // ===== Simulation state =====
    let simTimeYears = 0;

    const updateTimeLabel = () => {
      const days = simTimeYears * 365.25;
      if (timeLabel) timeLabel.textContent = `t = ${simTimeYears.toFixed(2)} Jahre (${Math.round(days)} Tage)`;
    };

    let followName = "none";
    if (followSel) followSel.addEventListener("change", () => { followName = followSel.value; });

    const resetView = () => {
      followName = "none";
      if (followSel) followSel.value = "none";
      controls.target.set(0, 0, 0);
      camera.position.set(0, 18, 52);
      controls.update();
    };
    if (resetBtn) resetBtn.addEventListener("click", resetView);

    // ===== Resize (WICHTIG: size korrekt setzen) =====
    const resize = () => {
      const w = wrap.clientWidth || 800;
      const h = wrap.clientHeight || 520;
      renderer.setSize(w, h, false);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    };
    resize();
    window.addEventListener("resize", resize);

    // ===== Animate =====
    const clock = new THREE.Clock();

    function tick(){
      const dt = clock.getDelta();
      const daysPerStep = speed ? Number(speed.value) : 1.0;
      const stepYears = daysPerStep * DAY_IN_YEARS * (dt * 30);
      simTimeYears += stepYears;

      for (const [name, obj] of bodies.entries()){
        const { def, mesh } = obj;
        if (!def.a) continue;

        const w = (2 * Math.PI) / def.periodY;
        obj.theta += w * stepYears;

        const a = def.a * AU_SCALE;
        const e = def.e;
        const x = (a * Math.cos(obj.theta) - a * e);
        const z = (a * Math.sin(obj.theta) * Math.sqrt(1 - e * e));
        mesh.position.set(x, 0, z);
      }

      if (earth){
        const ex = earth.mesh.position.x;
        const ez = earth.mesh.position.z;

        const rMoon = 0.00257 * AU_SCALE;
        bodies.get("Mond").theta += (2 * Math.PI / 0.0748) * stepYears;
        const mt = bodies.get("Mond").theta;
        moonMesh.position.set(ex + rMoon * Math.cos(mt), 0, ez + rMoon * Math.sin(mt));

        const rISS = 0.000045 * AU_SCALE;
        bodies.get("ISS").theta += (2 * Math.PI / 0.00106) * stepYears;
        const it = bodies.get("ISS").theta;
        issMesh.position.set(ex + rISS * Math.cos(it), 0, ez + rISS * Math.sin(it));

        const rGPS = 0.000178 * AU_SCALE;
        bodies.get("GPS-1").theta += (2 * Math.PI / 0.5) * stepYears;
        const gt = bodies.get("GPS-1").theta;
        gpsMesh.position.set(ex + rGPS * Math.cos(gt), 0, ez + rGPS * Math.sin(gt));

        const rSL = 0.000055 * AU_SCALE;
        bodies.get("Starlink-1").theta += (2 * Math.PI / 0.08) * stepYears;
        const st = bodies.get("Starlink-1").theta;
        const inc = THREE.MathUtils.degToRad(53);
        const y = Math.sin(st) * Math.sin(inc) * rSL;
        slMesh.position.set(ex + rSL * Math.cos(st), y, ez + rSL * Math.sin(st) * Math.cos(inc));
      }

      if (followName !== "none" && bodies.has(followName)){
        const p = bodies.get(followName).mesh.position;
        controls.target.lerp(p, 0.08);
      }

      updateTimeLabel();
      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }

    updateTimeLabel();
    tick();
  </script>
</body>
</html>
